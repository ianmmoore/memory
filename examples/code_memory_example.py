"""Example usage of the code memory system.

This script demonstrates how to use the CodeMemorySystem for indexing
codebases and retrieving relevant code context using LLM-based scoring.
"""

import asyncio
import sys
import tempfile
import os
from pathlib import Path

sys.path.insert(0, '..')

from memory_lib import CodeMemorySystem
from memory_lib.codebase import CodeContext


# Mock LLM functions for demonstration

async def mock_small_model(prompt: str) -> str:
    """Mock small model for scoring code relevance.

    In production, replace with actual API calls to GPT-3.5, Claude Haiku, etc.
    """
    prompt_lower = prompt.lower()

    # Score based on keywords and context
    score = 0.5  # Default

    if "auth" in prompt_lower and "authentication" in prompt_lower:
        score = 0.95
    elif "login" in prompt_lower or "validate" in prompt_lower:
        score = 0.85
    elif "user" in prompt_lower or "token" in prompt_lower:
        score = 0.75
    elif "error" in prompt_lower and "attributeerror" in prompt_lower:
        score = 0.9

    return f"Score: {score}\nReason: Relevance based on code context and task"


async def mock_primary_model(prompt: str) -> str:
    """Mock primary model for generating code responses.

    In production, replace with actual API calls to GPT-4, Claude Opus, etc.
    """
    return """Based on the code context provided, here's my recommendation:

1. Add proper null checks before accessing the token attribute
2. Implement error handling with try-except blocks
3. Add logging for debugging purposes

Here's the suggested implementation:
[This would be actual code generated by the LLM]
"""


def create_example_codebase(temp_dir: str):
    """Create a small example codebase for demonstration."""

    # Create directory structure
    api_dir = Path(temp_dir) / "api"
    utils_dir = Path(temp_dir) / "utils"
    api_dir.mkdir(parents=True, exist_ok=True)
    utils_dir.mkdir(parents=True, exist_ok=True)

    # Create auth.py
    (api_dir / "auth.py").write_text("""\"\"\"Authentication module for the API.\"\"\"

import jwt
from datetime import datetime, timedelta

def generate_token(user_id: str, secret: str) -> str:
    \"\"\"Generate a JWT token for a user.

    Args:
        user_id: The user's unique identifier
        secret: Secret key for signing the token

    Returns:
        JWT token as string
    \"\"\"
    payload = {
        'user_id': user_id,
        'exp': datetime.utcnow() + timedelta(hours=24)
    }
    return jwt.encode(payload, secret, algorithm='HS256')


def validate_token(token: str, secret: str) -> dict:
    \"\"\"Validate and decode a JWT token.

    Args:
        token: JWT token to validate
        secret: Secret key for verification

    Returns:
        Decoded token payload

    Raises:
        jwt.InvalidTokenError: If token is invalid
    \"\"\"
    return jwt.decode(token, secret, algorithms=['HS256'])


class AuthHandler:
    \"\"\"Handler for authentication operations.\"\"\"

    def __init__(self, secret: str):
        self.secret = secret

    def login(self, username: str, password: str) -> str:
        \"\"\"Authenticate user and return token.\"\"\"
        # Validate credentials (simplified)
        if self._validate_credentials(username, password):
            return generate_token(username, self.secret)
        raise ValueError("Invalid credentials")

    def _validate_credentials(self, username: str, password: str) -> bool:
        \"\"\"Validate user credentials against database.\"\"\"
        # This would query a database in production
        return username and password
""")

    # Create handlers.py
    (api_dir / "handlers.py").write_text("""\"\"\"Request handlers for the API.\"\"\"

from .auth import AuthHandler


async def handle_login_request(request):
    \"\"\"Handle user login requests.\"\"\"
    username = request.get('username')
    password = request.get('password')

    auth_handler = AuthHandler(secret="my-secret")
    token = auth_handler.login(username, password)

    return {'token': token, 'success': True}


async def handle_protected_request(request):
    \"\"\"Handle requests that require authentication.\"\"\"
    token = request.headers.get('Authorization')

    # This is where the bug might be - no null check!
    user_data = validate_token(token)

    return {'data': 'protected data', 'user': user_data}
""")

    # Create utils.py
    (utils_dir / "helpers.py").write_text("""\"\"\"Utility helper functions.\"\"\"

import logging

logger = logging.getLogger(__name__)


def log_error(error: Exception, context: str = ""):
    \"\"\"Log an error with context information.

    Args:
        error: The exception that occurred
        context: Additional context about where the error happened
    \"\"\"
    logger.error(f"Error in {context}: {type(error).__name__}: {str(error)}")


def sanitize_input(input_str: str) -> str:
    \"\"\"Sanitize user input to prevent injection attacks.

    Args:
        input_str: Raw input string

    Returns:
        Sanitized string
    \"\"\"
    # Basic sanitization (expand in production)
    return input_str.strip().replace('<', '').replace('>', '')
""")

    return temp_dir


async def main():
    """Main example demonstrating the code memory system."""

    print("=" * 70)
    print("Code Memory System Example")
    print("=" * 70)
    print()

    # Create a temporary example codebase
    with tempfile.TemporaryDirectory() as temp_dir:
        print("1. Creating example codebase...")
        create_example_codebase(temp_dir)
        print(f"   ✓ Created example codebase in {temp_dir}")
        print()

        # 2. Initialize the code memory system
        print("2. Initializing code memory system...")
        code_memory = CodeMemorySystem(
            small_model_fn=mock_small_model,
            db_path="example_code_memories.db",
            relevance_threshold=0.7,
            max_memories=10,
            enable_caching=True,
            enable_dependency_boost=True,
            enable_recency_boost=True
        )
        print("   ✓ System initialized with caching and optimizations enabled")
        print()

        # 3. Index the repository
        print("3. Indexing the repository...")
        entities = code_memory.index_repository(
            temp_dir,
            exclude_patterns=["*/__pycache__/*", "*.pyc"],
            recursive=True
        )
        print(f"   ✓ Indexed {len(entities)} code entities")
        for entity in entities[:5]:  # Show first 5
            print(f"      - {entity['entity_name']} in {entity['file_path']}")
        if len(entities) > 5:
            print(f"      ... and {len(entities) - 5} more")
        print()

        # 4. Add documentation memory
        print("4. Adding documentation memory...")
        doc_id = code_memory.add_documentation_memory(
            title="API Authentication Architecture",
            content="""Our API uses JWT-based authentication.

            Flow:
            1. User sends credentials to /login endpoint
            2. Server validates and returns JWT token
            3. Client includes token in Authorization header
            4. Server validates token for protected endpoints

            Important: Always check if token exists before validation!
            """,
            category="architecture"
        )
        print(f"   ✓ Added documentation (ID: {doc_id[:8]})")
        print()

        # 5. Add debugging session memory
        print("5. Adding debugging session memory...")
        debug_id = code_memory.add_debugging_session(
            title="Fixed NoneType error in token validation",
            content="""Issue: AttributeError when accessing token attribute

            Root cause: No null check before calling validate_token()

            Solution: Added check for token existence before validation
            """,
            metadata={"severity": "high", "date": "2024-01-15"}
        )
        print(f"   ✓ Added debugging session (ID: {debug_id[:8]})")
        print()

        # 6. Get statistics
        print("6. System statistics:")
        stats = code_memory.get_stats()
        print(f"   Code memories: {stats['code_memories']}")
        print(f"   Non-code memories: {stats['non_code_memories']}")
        print(f"   Total: {stats['total_memories']}")
        print(f"   Cache size: {stats['cache']['cache_size']}")
        print(f"   Caching enabled: {stats['cache']['caching_enabled']}")
        print(f"   Dependency boost: {stats['cache']['dependency_boost_enabled']}")
        print()

        # 7. Create a code context for retrieval
        print("7. Creating code context for a bug fix task...")
        context = CodeContext(
            user_query="Fix the AttributeError in the authentication handler",
            current_file="api/handlers.py",
            errors="AttributeError: 'NoneType' object has no attribute 'token'",
            accessed_files=["api/auth.py", "api/handlers.py"]
        )
        print("   Context:")
        print(f"   - Task: {context.user_query}")
        print(f"   - Current file: {context.current_file}")
        print(f"   - Error: {context.errors}")
        print()

        # 8. Retrieve relevant memories
        print("8. Retrieving relevant code memories...")
        relevant_memories = await code_memory.retrieve_relevant_memories(context)
        print(f"   Found {len(relevant_memories)} relevant memories:")
        for i, mem in enumerate(relevant_memories, 1):
            print(f"   {i}. Score: {mem.relevance_score:.2f}")
            print(f"      {mem.text}")
            print(f"      Reason: {mem.reasoning[:60]}...")
            print()

        # 9. Format for prompt
        print("9. Formatting memories for prompt...")
        formatted = code_memory.format_memories_for_prompt(
            relevant_memories,
            group_by_file=True
        )
        print("   First 300 characters of formatted output:")
        print("   " + "-" * 66)
        print("   " + formatted[:300] + "...")
        print("   " + "-" * 66)
        print()

        # 10. Complete query with primary model
        print("10. Running complete query...")
        response = await code_memory.query(
            context=context,
            primary_model_fn=mock_primary_model
        )
        print("    Response:")
        for line in response.split("\n")[:8]:
            print(f"    {line}")
        print("    ...")
        print()

        # 11. Test caching
        print("11. Testing cache (querying again with same context)...")
        relevant_memories_cached = await code_memory.retrieve_relevant_memories(context)
        cached_count = sum(1 for m in relevant_memories_cached if "[CACHED]" in m.reasoning)
        print(f"    ✓ {cached_count} results served from cache")
        print()

        # 12. Demonstrate file re-indexing
        print("12. Demonstrating file re-indexing...")
        test_file = Path(temp_dir) / "api" / "auth.py"
        if test_file.exists():
            count = code_memory.reindex_file(str(test_file))
            print(f"    ✓ Re-indexed {count} entities from {test_file.name}")
            print(f"    ✓ Cache invalidated for this file")
        print()

        # 13. Query with custom prompt
        print("13. Querying with custom prompt template...")
        custom_template = """Code Context:
{memories}

Current Task:
{context}

Please provide:
1. Root cause analysis
2. Specific fix with code
3. Testing strategy
"""
        response = await code_memory.query_with_custom_prompt(
            context=context,
            prompt_template=custom_template,
            primary_model_fn=mock_primary_model
        )
        print("    ✓ Query completed with custom template")
        print()

        # 14. Clean up
        print("14. Cleaning up...")
        count = code_memory.clear_all_memories()
        print(f"    ✓ Deleted {count} memories")
        print()

    print("=" * 70)
    print("Example completed successfully!")
    print("=" * 70)
    print()
    print("In production, replace mock LLM functions with actual API calls:")
    print("  - Use GPT-3.5/Claude Haiku for small_model_fn")
    print("  - Use GPT-4/Claude Opus for primary_model_fn")
    print()


if __name__ == "__main__":
    asyncio.run(main())
